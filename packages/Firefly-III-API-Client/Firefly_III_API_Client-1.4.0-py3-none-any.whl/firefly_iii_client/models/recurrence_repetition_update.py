# coding: utf-8

"""
    Firefly III API Client

    This is the Python client for Firefly III API  # noqa: E501

    The version of the OpenAPI document: 0.10.0
    Contact: thegrumpydictator@gmail.com
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six


class RecurrenceRepetitionUpdate(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'moment': 'str',
        'skip': 'int',
        'type': 'str',
        'weekend': 'int'
    }

    attribute_map = {
        'moment': 'moment',
        'skip': 'skip',
        'type': 'type',
        'weekend': 'weekend'
    }

    def __init__(self, moment=None, skip=None, type=None, weekend=None):  # noqa: E501
        """RecurrenceRepetitionUpdate - a model defined in OpenAPI"""  # noqa: E501

        self._moment = None
        self._skip = None
        self._type = None
        self._weekend = None
        self.discriminator = None

        self.moment = moment
        if skip is not None:
            self.skip = skip
        self.type = type
        if weekend is not None:
            self.weekend = weekend

    @property
    def moment(self):
        """Gets the moment of this RecurrenceRepetitionUpdate.  # noqa: E501

        Information that defined the type of repetition. - For 'daily', this is empty. - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday). - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month - For 'monthly' it is the day of the month (1 - 31) - For yearly, it is a full date, ie '2018-09-17'. The year you use does not matter.   # noqa: E501

        :return: The moment of this RecurrenceRepetitionUpdate.  # noqa: E501
        :rtype: str
        """
        return self._moment

    @moment.setter
    def moment(self, moment):
        """Sets the moment of this RecurrenceRepetitionUpdate.

        Information that defined the type of repetition. - For 'daily', this is empty. - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday). - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month - For 'monthly' it is the day of the month (1 - 31) - For yearly, it is a full date, ie '2018-09-17'. The year you use does not matter.   # noqa: E501

        :param moment: The moment of this RecurrenceRepetitionUpdate.  # noqa: E501
        :type: str
        """
        if moment is None:
            raise ValueError("Invalid value for `moment`, must not be `None`")  # noqa: E501

        self._moment = moment

    @property
    def skip(self):
        """Gets the skip of this RecurrenceRepetitionUpdate.  # noqa: E501

        How many occurrences to skip. 0 means skip nothing. 1 means every other.  # noqa: E501

        :return: The skip of this RecurrenceRepetitionUpdate.  # noqa: E501
        :rtype: int
        """
        return self._skip

    @skip.setter
    def skip(self, skip):
        """Sets the skip of this RecurrenceRepetitionUpdate.

        How many occurrences to skip. 0 means skip nothing. 1 means every other.  # noqa: E501

        :param skip: The skip of this RecurrenceRepetitionUpdate.  # noqa: E501
        :type: int
        """

        self._skip = skip

    @property
    def type(self):
        """Gets the type of this RecurrenceRepetitionUpdate.  # noqa: E501

        The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.  # noqa: E501

        :return: The type of this RecurrenceRepetitionUpdate.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this RecurrenceRepetitionUpdate.

        The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.  # noqa: E501

        :param type: The type of this RecurrenceRepetitionUpdate.  # noqa: E501
        :type: str
        """
        if type is None:
            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
        allowed_values = ["daily", "weekly", "ndom", "monthly", "yearly"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def weekend(self):
        """Gets the weekend of this RecurrenceRepetitionUpdate.  # noqa: E501

        How to respond when the recurring transaction falls in the weekend. Possible values: 1. Do nothing, just create it 2. Create no transaction. 3. Skip to the previous Friday. 4. Skip to the next Monday.   # noqa: E501

        :return: The weekend of this RecurrenceRepetitionUpdate.  # noqa: E501
        :rtype: int
        """
        return self._weekend

    @weekend.setter
    def weekend(self, weekend):
        """Sets the weekend of this RecurrenceRepetitionUpdate.

        How to respond when the recurring transaction falls in the weekend. Possible values: 1. Do nothing, just create it 2. Create no transaction. 3. Skip to the previous Friday. 4. Skip to the next Monday.   # noqa: E501

        :param weekend: The weekend of this RecurrenceRepetitionUpdate.  # noqa: E501
        :type: int
        """

        self._weekend = weekend

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, RecurrenceRepetitionUpdate):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
