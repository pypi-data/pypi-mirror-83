# AUTOGENERATED! DO NOT EDIT! File to edit: db.ipynb (unless otherwise specified).

__all__ = ['Helper', 'SecondaryBase', 'TmCodeIndex', 'TmRefcodeIndex', 'PynamoMember', 'PynamoLog', 'getMember',
           'setMember', 'addMember', 'removeMember', 'test', 'tableName', 'logName']

# Cell
from json.decoder import JSONDecodeError
from botocore.config import Config
from s3bz.s3bz import S3, Requests
from lambdasdk.lambdasdk import Lambda
from awsSchema.apigateway import Event, Response
from datetime import datetime as dt
from pynamodb.models import Model
from pynamodb.attributes import UnicodeAttribute, NumberAttribute, JSONAttribute
from pynamodb.indexes import GlobalSecondaryIndex, AllProjection
from collections import OrderedDict
import json, logging, os

# Cell

tableName = os.environ.get('TABLE_NAME')
logName = os.environ.get('LOG_TABLE')
if not tableName or not logName:
  logging.error('missing TABLE_NAME {tableName} or LOG_TABLE {logName}, please set the environment variables')

class Helper:
    @staticmethod
    def removeNone(data):
        return { k:v for k, v in data.items() if v is not None }

    @staticmethod
    def returnError(errorMessage, errorCode = 400):
        return Response.getReturn(statusCode=errorCode, body = errorMessage)



#define pynamodb class
class SecondaryBase:
  class Meta:
    table_name = tableName
    region = 'ap-southeast-1'
    projection = AllProjection()
    read_capacity_units = 1
    write_capacity_units = 1

class TmCodeIndex(GlobalSecondaryIndex, SecondaryBase):
  '''query tm_code'''
  class Meta:
    table_name = tableName
    region = 'ap-southeast-1'
    projection = AllProjection()
    read_capacity_units = 1
    write_capacity_units = 1
    index_name = 'tm_code'
  tm_code = UnicodeAttribute(hash_key = True)

class TmRefcodeIndex(GlobalSecondaryIndex, SecondaryBase):
  '''query tm_refcode'''
  class Meta:
    table_name = tableName
    region = 'ap-southeast-1'
    projection = AllProjection()
    read_capacity_units = 1
    write_capacity_units = 1
    index_name = 'tm_refcode'
  tm_refcode = UnicodeAttribute(hash_key = True)

class PynamoMember(Model):
  ''' pynamo member'''
  class Meta:
    table_name = tableName
    region = 'ap-southeast-1'
  hashedPhone = UnicodeAttribute(hash_key = True)
  tm_code = UnicodeAttribute(range_key=True)
  tm_refcode = UnicodeAttribute(default='none')
  data = JSONAttribute()
  #indexes
  tmCodeIndex = TmCodeIndex()
  tmRefcodeIndex = TmRefcodeIndex()
  @classmethod
  def fromData(cls, data):
    pynamoMember = cls(
      hashedPhone = data['hashedPhone'],
      tm_code = data.get('tm_code') or 'none',
      tm_refcode = data.get('tm_refcode') or 'none',
      data = data
    )
    return pynamoMember

class PynamoLog(Model):
    ''' log changes to pynamo member '''
    class Meta:
      table_name = logName
      region = 'ap-southeast-1'
    logType = UnicodeAttribute(hash_key = True)
    timestamp = NumberAttribute(range_key=True)
    logMessage = UnicodeAttribute()
    responseObject = JSONAttribute()
    @classmethod
    def logWrite(cls, message:str, responseObject = {'message': 'not specified'}):
        dynamoLogger = cls(
            logType = 'write',
            timestamp = dt.now().timestamp(),
            logMessage = message,
            responseObject = responseObject
        )
        return dynamoLogger.save()

    @classmethod
    def logRead(cls, message:str, responseObject = {'message': 'not specified'}):
        dynamoLogger = cls(
            logType = 'read',
            timestamp = dt.now().timestamp(),
            logMessage = message,
            responseObject = responseObject
        )
        return dynamoLogger.save()




# get input structure = {hashedPhone: string?, memberId: string? }
# output = {statuscode: int, body:{message: string, input: dict, members: dict}}
def getMember(event, *args):
  if all(event.get(k) == None for k in ['hashedPhone', 'tm_code', 'tm_refcode']):
      return Helper.returnError(f'missing keys keys are{event.keys()}')
  c = PynamoMember
  keys = OrderedDict([('hashedPhone',c), ('tm_code',c.tmCodeIndex), ('tm_refcode',c.tmRefcodeIndex)])
  for k,v in keys.items():
    if item:=event.get(k):
      results = [it.data for it in v.query(item)]
      if len(results) > 1:
        # filter for tm_code or tm_refcode
        logging.info('found more than 1 member, filtering')
        filteredResult=[r for r in results \
                if any(event.get(k) == r.get(k) for k in keys.keys() if k!='hashedPhone')]
        if not filteredResult:
          logging.warning('missing filtered result, return all')
          pass
        else: results = [filteredResult[0]]
      if not results: return Helper.returnError('no members found')
      return Response.getReturn(body={"members":results})
def setMember(event, *args):
    '''add features to the currently available member'''
    # check if hashedPhone is present
    if not event.get('hashedPhone'): return Helper.returnError(f'hashedPhone is not available{event}', errorCode = 400)


    # check if member in the list
    memberResponse = getMember(event, *args)
    if memberResponse['statusCode'] != 200: return Helper.returnError( memberResponse )

    # check if getting more than 1 member
    members = Response.fromDict(memberResponse).body['members']
    if len(members) != 1: return Helper.returnError(f'getting more than 1 member {json.dumps(members)}')


    #update member
    member = members[0]
    member.update(event)
    pynamoMember = PynamoMember.fromData(member)
    saveResult = pynamoMember.save()
    logResult = PynamoLog.logWrite(message = 'updatingmember',responseObject= member)
    if not logResult.get('ConsumedCapacity'): return Helper.returnError(f'logging failed {logResult}')

    return {
        "statusCode": 200,
        "body": json.dumps({
            "message": "successfully get new member",
            "input": event,
            "saveResult": saveResult
        })
    }

# add input structure = {hashedPhone: string, memberId: string ....}
def addMember(event, *args):
    '''add new member'''
    # check if both hashed phone and member id are present
    if any(event.get(k)==None for k in ['hashedPhone', 'tm_code', 'tm_refcode']):
        return Helper.returnError(f'missing keys')

#     member = PynamoMember(
#         hashedPhone = event.get('hashedPhone'),
#         memberId = event.get('memberId'),
#         data = event
#     )
    member = PynamoMember.fromData(event)
    response = member.save()

    PynamoLog.logWrite(message='write from function addMember',responseObject=response)

    return {
        "statusCode": 200,
        "body": json.dumps({
            "message": "successfully created new member",
            "input": event
        })
    }

def removeMember(event, *args):
    '''remove a member'''
    # check that both hashed phone and member id are present
    if not event.get('hashedPhone'): return Helper.returnError(f'hashedPhone is not available{event}', errorCode = 400)
    if not event.get('tm_code'): return Helper.returnError(f'memberId is not available{event}', errorCode = 400)

    # check if member in the list
    memberResponse = getMember(event, *args)
    if memberResponse['statusCode'] != 200: return Helper.returnError( memberResponse )

    # check if getting more than 1 member
    members = json.loads(memberResponse.get('body'))['members']
    if len(members) != 1: return Helper.returnError(f'getting more than 1 member {json.dumps(members)}')


    #delete member
    member = members[0]
    pynamoMember = PynamoMember.fromData(member)
    saveResult = pynamoMember.delete()
    logResult = PynamoLog.logWrite(message = 'deleteingMember',responseObject= member)
    if not logResult.get('ConsumedCapacity'): return Helper.returnError(f'logging failed {logResult}')

    return {
        "statusCode": 200,
        "body": json.dumps({
            "message": "successully deleted member",
            "input": event
        })
    }

def test(event ,*args):
    '''testing all functions'''
    testData = {
        'hashedPhone': 'testHashPhone',
        'tm_code': '12424',
        'tm_refcode': '3r23',
        'someRandomKey': 'testRandomData',
        '_underscoreKey': 'underscoreKey',
        'blankKey': None
    }

    print(f'test add member {addMember(testData,"")}')
    print(f'test set member {setMember(testData,"")}')
    print(f'test get member {getMember(testData,"")}')
    print(f'test delete member {removeMember(testData,"")}')


